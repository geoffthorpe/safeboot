HCP_SRC := $(TOP)/hcp
HCP_OUT := $(TOP)/build/hcp

$(HCP_OUT): | build
MDIRS += $(HCP_OUT)

# Used in dependency chains, as a change in these files can have effects that
# require rebuilding other things.
HCP_DEPS_COMMON := $(TOP)/Makefile $(HCP_SRC)/settings.mk $(HCP_SRC)/Makefile

# Configuration settings. (From wherever. A developer, a CI pipeline, some
# package-building machinery, ...)
include hcp/settings.mk

# Utility script to simplify the workflow (depends on hcp/settings.mk)
ifeq (,$(SAFEBOOT_HCP_SUBMODULE_RESET_DISABLE))
ASSIST_CLEANUP=$(HCP_SRC)/assist_cleanup.sh
else
ASSIST_CLEANUP=DISABLE_SUBMODULE_RESET=1 $(HCP_SRC)/assist_cleanup.sh
endif

# Utility script to allow synchronization based on logfile/stdout/stderr
TAIL_WAIT=$(HCP_SRC)/tail_wait.pl

# To allow for more efficient "clean" recipes, capture a listing of
# already-built and already-running images.
HCP_EXISTING_IMAGES := $(shell docker image ls \
			--filter label=$(SAFEBOOT_HCP_DSPACE)all \
			--format "{{.Repository}}" 2> /dev/null)
HCP_RUNNING_CONTAINERS := $(shell docker container ls \
			--filter label=$(SAFEBOOT_HCP_DSPACE)all \
			--format "{{.Names}}" 2> /dev/null)
HCP_EXISTING_CONTAINERS := $(shell docker container ls -a \
			--filter label=$(SAFEBOOT_HCP_DSPACE)all \
			--format "{{.Names}}" 2> /dev/null)
HCP_EXISTING_NETWORKS := $(shell docker network ls \
			--filter label=$(SAFEBOOT_HCP_DSPACE)all \
			--format "{{.Name}}" 2> /dev/null)

# There are various components that get produced as tarballs after being staged in
# host directories (under build/), and these are later consumed by Dockerfiles that
# have autogenerated commands appended to them by the build system. To avoid
# host oddities influencing the images (e.g. via umasks, setuid/setgid bits,
# ...), we use the following constructs for all tarball extractions;

# tarball_extract adds Dockerfile commands to copy foobar.tar.gz to the
# container image, extract it into a well-known temporary location, and then
# remove the tarball;
#     echo "$(call tarball_extract,foobar)" >> some/random/Dockerfile
tarball_extract = \# From tarball_extract($1)
tarball_extract += \nCOPY $1.tar.gz /
tarball_extract += \nRUN mkdir -p /tmp-hcp-tarball
tarball_extract += \nRUN cd /tmp-hcp-tarball && tar zxf /$1.tar.gz && rm /$1.tar.gz

# tarball_finalize adds Dockerfile commands to chown and chmod the directories
# and files from the well-known temporary directory, then move them all to the
# root directory and remove the temporary directory. Multiple tarball_extract
# sections can preceed the single (parameter-less) tarball_finalize section;
#     echo "$(call tarball_finalize)" >> some/random/Dockerfile
tarball_finalize = \# From tarball_finalize()
tarball_finalize += \nRUN cd /tmp-hcp-tarball && chown -R root:root *
tarball_finalize += \nRUN cd /tmp-hcp-tarball && find . -type d -exec chmod 755 {} \;
tarball_finalize += \nRUN cd /tmp-hcp-tarball && find . ! -type d -executable -exec chmod 755 {} \;
tarball_finalize += \nRUN cd /tmp-hcp-tarball && find . ! -type d ! -executable -exec chmod 644 {} \;
tarball_finalize += \nRUN cd /tmp-hcp-tarball && mv * / && cd / && rmdir /tmp-hcp-tarball

# A "base platform" Docker image is created, and used as a basis for deriving
# two kinds of images;
# - a "builder" container image, containing tool-chains and other extras to
#   facilitate the building of safeboot submodules.
# - application container images, providing the different services, side-cars,
#   and utilities that constitue HCP.
include hcp/base/Makefile

# A "builder" docker image is created that can host safeboot's building of
# submodule code (rather it than building directly in the host environment,
# which can be undesirable, unreliable, or impossible for many reasons).
include hcp/builder/Makefile

# Compile submodules (using "builder"), resulting in install.tar.gz, literally
# a tarball of a root-level installation ("/install") of the submodules.
include hcp/submodules/Makefile

# Produce tarballs of scripts, for installation into containers. This includes
# safeboot.tar.gz (literally a tarball of safeboot scripts in an installed
# path) and hcp-<x>.tar.gz for <x> in {enrollsvc,attestsvc,swtpmsvc,client}.
include hcp/scripts/Makefile

# TODO: the creating, destroy, starting, and stopping of instances (both
# Enrollment and Attestation) is currently mingled into the Makefiles that
# build the service containers. This will change. But for now, we want those
# instances to connect to each other on a docker network, so provide the
# definitions and support before including the Enrollment/Attestation Service
# Makefiles.
include hcp/testnetwork.Makefile

# Enrollment Service
include hcp/enrollsvc/Makefile

# Attestation Service
include hcp/attestsvc/Makefile

# Software TPM
include hcp/swtpmsvc/Makefile

# Example client/host (containerized)
include hcp/client/Makefile

# A devel/debug image that has the whole kit and caboodle
include hcp/caboodle/Makefile

# Rule to build everything (unmentioned stuff, like submodules, is dragged in
# by dependency)
hcp_buildall: hcp_enrollsvc hcp_attestsvc hcp_swtpmsvc hcp_client hcp_caboodle

# Rule to run everything
hcp_startall: hcp_enrollsvc_run_start hcp_attestsvc_run_start hcp_swtpmsvc_run_start hcp_client_run
hcp_stopall: hcp_enrollsvc_run_stop hcp_attestsvc_run_stop hcp_swtpmsvc_run_stop
hcp_runall: hcp_startall
	$Qecho "Services started and client completed, tearing down"
	$Q$(MAKE) hcp_stopall
hcp_clearall: clean_hcp_enrollsvc_run clean_hcp_attestsvc_run clean_hcp_swtpmsvc_run
hcp_clearall: clean_hcp_client_run clean_hcp_caboodle_run

# This target allows you to shell into a running container (using docker exec).
# If CID is set, it attempts to shell into the container it identifies,
# otherwise a listing of running containers is given.

enter:
ifeq (,$(CID))
	$Qecho "To shell into a running container, select the desired container by setting CID to"
	$Qecho "the corresponding 'CONTAINER ID'. Note, you only need to specify enough of the"
	$Qecho "initial hexadecimal characters to distinguish it from other containers."
	$Qecho
	$Qecho "Currently running containers in this project;"
	$Qdocker container ls --filter=label=$(SAFEBOOT_HCP_DSPACE)all
	$Qecho
	$Qecho "E.g.:   make enter CID=f00d"
	$Qecho
else
	$Qdocker exec -it $(CID) /bin/bash
endif

clean_hcp:
	$Qrm -rf $(HCP_OUT)

# Make sure "hcp_clean" runs before "clean"
clean: clean_hcp
