VOLUMES += vsbin vfunctionssh vsafebootconf vtailwait
vsbin_MANAGED := false
vsbin_SOURCE := $(TOPDIR)/sbin
vsbin_DEST := /safeboot/sbin
vfunctionssh_MANAGED := false
vfunctionssh_SOURCE := $(TOPDIR)/functions.sh
vfunctionssh_DEST := /safeboot/functions.sh
vsafebootconf_MANAGED := false
vsafebootconf_SOURCE := $(TOPDIR)/safeboot.conf
vsafebootconf_DEST := /safeboot/safeboot.conf
vtailwait_MANAGED := false
vtailwait_SOURCE := $(TOPDIR)/workflow/tail_wait.pl
vtailwait_DEST := /safeboot/tail_wait.pl

NETWORKS += n-attest

MSGBUS := $(DEFAULT_CRUD)/msgbus_simple-attest
MSGBUSC := client
MSGBUSS := server

IMAGES += simple-attest-client
simple-attest-client_EXTENDS := $(ibase-RESULT)
simple-attest-client_PATH := $(TOPDIR)/workflow/simple-attest-client
simple-attest-client_COMMANDS := shell run
simple-attest-client_SUBMODULES := libtpms swtpm tpm2-tss tpm2-tools
simple-attest-client_VOLUMES := vsbin vfunctionssh vsafebootconf vtailwait \
	$(foreach i,$(simple-attest-client_SUBMODULES),vi$i)
simple-attest-client_NETWORKS := n-attest
simple-attest-client_run_COMMAND := /run_client.sh
simple-attest-client_run_PROFILES := detach_join
simple-attest-client_run_MSGBUS := $(MSGBUS)
simple-attest-client_run_HIDE := 1
simple-attest-client_ARGS_DOCKER_BUILD := \
	--build-arg SUBMODULES="$(simple-attest-client_SUBMODULES)" \
	--build-arg DIR="/safeboot"

IMAGES += simple-attest-server
simple-attest-server_EXTENDS := $(ibase-RESULT)
simple-attest-server_PATH := $(TOPDIR)/workflow/simple-attest-server
simple-attest-server_SUBMODULES :=
simple-attest-server_COMMANDS := shell run
simple-attest-server_VOLUMES := vsbin vfunctionssh vsafebootconf vtailwait \
	$(foreach i,$(simple-attest-server_SUBMODULES),vi$i)
simple-attest-server_NETWORKS := n-attest
simple-attest-server_run_COMMAND := /run_server.sh
simple-attest-server_run_PROFILES := detach_join
simple-attest-server_run_MSGBUS := $(MSGBUS)
#simple-attest-server_run_HIDE := 1
simple-attest-server_ARGS_DOCKER_BUILD := \
	--build-arg SUBMODULES="$(simple-attest-server_SUBMODULES)" \
	--build-arg DIR="/safeboot"
# Give the server a secrets.yaml as well as access to the client's msgbus
simple-attest-server_ARGS_DOCKER_RUN := \
	-v=$(TOPDIR)/workflow/stub-secrets.yaml:/safeboot/secrets.yaml

# Digest and process the above definitions (generate a Makefile and source it
# back in) before continuing. In that way, we can build subsequent definitions
# not just using what we defined above, but also using what the Mariner
# machinery defined as a consequence of the above.
$(eval $(call do_mariner))

# Autogenerated attributes are now set and can be used (such as
# <image>_<verb>_<TOUCHFILE|JOINFILE/DONEFILE>).

# Trail of dependencies for the "simple-attest" use-case;
# A: "simple-attest" depends on;
#   -  <client>_run_DONEFILE (exit of the client container)
#   -  <server>_run_DONEFILE (exit of the server container)
#     --> once met, delete SUnderway+SMsgbus
# B: <client>_run_DONEFILE and <server>_run_DONEFILE depend on;
#   - SUnderway, an intermediate dependency between the DONE and JOIN files for
#     both client and server, in order to force both to start before waiting
#     for either to finish.
# C: SUnderway depends on;
#   -  <client>_run_JOINFILE (launch of the client container)
#   -  <server>_run_JOINFILE (launch of the server container)
#     --> once met, create SUnderway
# D: <client>_run_JOINFILE and <server>_run_JOINFILE depend on;
#   - SMsgbus, a dependency to ensure the msgbus files are cleared out before
#     the containers are launched. (Otherwise, their wait-on-<x> logic will
#     match on strings from a previous run.)
#   - <module>_install_TOUCHFILE (for all <module>s that must be built and
#     installed)
#   - <network>_TOUCHFILE
# E: SMsgbus depends on nothing
#     --> clear msgbus contents
#     --> create empty msgbus files. (Client and server tail_wait(.sh) each
#         other via these files for synchronisation purposes, and you can't
#         tail_wait on a file that doesn't exist. If we don't precreate, they
#         won't exist until they're first written to, so we do this to avoid a
#         race condition.)
#     --> create SMsgbus

S:=simple-attest
SC:=$S-client
SS:=$S-server
SCRun:=$(SC)_run
SSRun:=$(SS)_run
SCRunLaunch:=$($(SCRun)_JOINFILE)
SSRunLaunch:=$($(SSRun)_JOINFILE)
SCRunWait:=$($(SCRun)_DONEFILE)
SSRunWait:=$($(SSRun)_DONEFILE)
SUnderway:=$(DEFAULT_CRUD)/ztouch-$S-underway
SMsgbus:=$(DEFAULT_CRUD)/ztouch-$S-msgbus
SDeps:=$(foreach i,swtpm tpm2-tools,$(ibuild-$i_install_TOUCHFILE)) $(n-attest_TOUCHFILE)

# A: "simple-attest"
$S: $(SCRunWait) $(SSRunWait)
	$Qrm $(SUnderway) $(SMsgbus)
	$Qecho "$S: completed successfully"

# B: DONEFILEs
$(SCRunWait) $(SSRunWait): $(SUnderway)

# C: Sunderway
$(SUnderway): $(SCRunLaunch) $(SSRunLaunch)
	$Qtouch $(SUnderway)

# D: JOINFILEs
$(SCRunLaunch) $(SSRunLaunch): $(SDeps) $(SMsgbus)

# E: SMsgbus
$(SMsgbus):
	$Qmkdir -p "$(MSGBUS)"
	$Q(cd "$(MSGBUS)" && rm -f *)
	$Q(cd "$(MSGBUS)" && touch $(MSGBUSC) $(MSGBUSS))
	$Qtouch $(SMsgbus)
	$Qecho "$S: starting"

# Provide a rule for cleaning up anything that got wedged.
$S-clean:
	$Qecho "$S: cleanup procedure starting"
	$Q$(TOPDIR)/workflow/assist_cleanup.sh image $(DSPACE)_$(SC)
	$Q$(TOPDIR)/workflow/assist_cleanup.sh image $(DSPACE)_$(SS)
	$Q$(TOPDIR)/workflow/assist_cleanup.sh jfile $(SCRunLaunch)
	$Q$(TOPDIR)/workflow/assist_cleanup.sh jfile $(SSRunLaunch)
	$Q$(TOPDIR)/workflow/assist_cleanup.sh jfile $(SCRunWait)
	$Q$(TOPDIR)/workflow/assist_cleanup.sh jfile $(SSRunWait)
	$Q$(TOPDIR)/workflow/assist_cleanup.sh network $(DSPACE)_n-attest
	$Q$(TOPDIR)/workflow/assist_cleanup.sh jfile $(n-attest_TOUCHFILE)

